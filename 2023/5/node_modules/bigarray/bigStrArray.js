let chars = 'abcdefghijklmonpqrstuvwxyz';

class AlphabetRange {
  constructor (startingChar, endingChar) {
    if(typeof startingChar === 'number') {
      this.startingCharIndex = startingChar;
    } else {
      this.startingCharIndex = chars.indexOf(startingChar.toLowerCase());
    }

    if(typeof startingChar === 'number') {
      this.endingCharIndex = endingChar;
    } else {
      this.endingCharIndex = chars.indexOf(endingChar.toLowerCase());
    }
    this.next = undefined;
  }
  contains (char) {
    let charIndex = chars.indexOf(char.toLowerCase());
    if (charIndex >= this.startingCharIndex && charIndex <= this.endingCharIndex) {
      return true;
    } else {
      return false;
    }
  }
  toString() {
    return chars.slice(this.startingCharIndex, this.endingCharIndex+1);
  }
  isAdjacent(char) {
    let charIndex = chars.indexOf(char);
    if (charIndex + 1 === this.startingCharIndex || charIndex - 1 === this.endingCharIndex) {
      return true;
    } else {
      return false;
    }
  }
  joinAdjacent(char) {
    if(this.isAdjacent(char)) {
      let charIndex = chars.indexOf(char);
      if (charIndex > this.endingCharIndex) {
        return [new AlphabetRange(this.startingCharIndex, this.endingCharIndex + 1)];
      } else {
        return [new AlphabetRange(this.startingCharIndex-1, this.endingCharIndex)];
      }
    } else {
      return [new AlphabetRange(this.startingCharIndex, this.endingCharIndex)];
    }
  }
  joinAdjacentRange(aRange) {
    if (this.endingCharIndex === aRange.startingCharIndex-1 || this.startingCharIndex-1 === aRange.endingCharIndex) {
      let start = Math.min(aRange.startingCharIndex, this.startingCharIndex);
      let end = Math.max(aRange.endingCharIndex, this.endingCharIndex);
      return [new AlphabetRange(start, end)];
    } else {
      return [new AlphabetRange(this.startingCharIndex, this.endingCharIndex), new AlphabetRange(aRange.startingCharIndex, aRange.endingCharIndex)];
    }
  }
  splitOn(char) {
    if(this.contains(char)) {
      let charIndex = chars.indexOf(char);
      if(charIndex === this.startingCharIndex) {
        return [new AlphabetRange(this.startingCharIndex + 1, this.endingCharIndex)];
      } else if (charIndex === this.endingCharIndex) {
        return [new AlphabetRange(this.startingCharIndex, this.endingCharIndex - 1)];
      } else {
        return [new AlphabetRange(this.startingCharIndex, charIndex - 1), new AlphabetRange(charIndex + 1, this.endingCharIndex)];
      }
    } else {
      return [new AlphabetRange(this.startingCharIndex, this.endingCharIndex)];
    }
  }
  addNext (alphaRanges) {
    this.next = alphaRanges;
  }
}

class BigStrArray {
  constructor() {
    //Storage is an array of AlphaRanges
    this.storage = [];
  }
  push(word) {
    if(this.storage.length > 0) {
      let current = this.storage;
      let fastTrack = false;
      for (var i = 0; i < word.length; i ++) {
        if(!fastTrack) {
          let containingRange = this._contains(current, word[i]);
          if (containingRange) {
            current = containingRange.next;
          } else {
            fastTrack = true;
            let nextRange = new AlphabetRange(word[i], word[i]);
            current.push(nextRange);
            nextRange.next = [];
            current = nextRange.next;
          }
        } else {
          let nextRange = new AlphabetRange(word[i], word[i]);
          current.push(nextRange);
          nextRange.next = [];
          current = nextRange.next;
        }
      }
    } else {
      let current = this.storage;
      for (var i = 0; i < word.length; i ++) {
        let nextRange = new AlphabetRange(word[i], word[i]);
        current.push(nextRange);
        nextRange.next = [];
        current = nextRange.next;
      }
    }
  }
  _contains(arr, char) {
    let bucket;
    arr.forEach(aRange => {
      if(aRange.contains(char)) {
        bucket = aRange;
      }
    });
    return bucket;
  }
  contains(word) {
    let current = this.storage;
    for(var i = 0; i < word.length; i ++) {
      let index;
      let charExists = false;
      current.forEach((aRange, aRI) => {
        if(aRange.contains(word[i])) {
          index = aRI;
          charExists = true;
        }
      });
      if (!charExists) {
        return false;
      };
      current = current[index].next;
    }
    return true;
  }
  addRanges(...aRanges) {
    let current = this.storage;
    for(var i = 0; i < aRanges.length; i ++) {
      current.push(aRanges[i]);
      aRanges[i].next = [];
      current = aRanges[i].next;
    }
  }
}

module.exports = {
  AlphabetRange,
  BigStrArray
};