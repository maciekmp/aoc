const toNearestStep = (dist, step) => {
  if(dist % step === 0) {
    return dist;
  } else {
    return dist + (step - (dist % step));
  }
}

class Range {
  constructor(start, end, step) {
    this.start = start;
    this.end = end;
    this.step = step;
  }
  contains(elem) {
    if(!(elem >= this.start && elem <= this.end)) {
      return false;
    }
    if((elem-this.start)%this.step === 0) {
      return true;
    } else {
      return false;
    }
  }
  isAdjacent(elem) {
    if(elem - this.step === this.end || elem + this.step === this.start) {
      return true;
    } else {
      return false;
    }
  }
  toArray() {
    let retval = [];
    for (var i = this.start; i <= this.end; i += this.step) {
      retval.push(i);
    }
    return retval;
  }
  isAdjacentRange(range) {
    if(this.step !== range.step) {
      return false;
    } else if (this.start - this.step === range.end) {
      return true;
    } else if (this.end + this.step === range.start) {
      return true;
    }
  }
  join(range) {
    if(this.isAdjacentRange(range)) {
      let start = Math.min(range.start, this.start);
      let end = Math.max(range.end, this.end);
      return [new Range(start, end, this.step)];
    } else {
      return [new Range(this.start, this.end, this.step), new Range(range.start, range.end, range.step)];
    }
  }
  remove(elem) {
    if (this.contains(elem) && elem !== this.start && elem !== this.end) {
      return [new Range(this.start, elem-this.step, this.step), new Range(elem + this.step, this.end, this.step)];
    } else if (elem === this.start) {
      return [new Range(this.start + this.step, this.end, this.step)];
    } else if (elem === this.end) {
      return [new Range(this.start, this.end - this.step, this.step)];
    } else {
      return [new Range(this.start, this.end, this.step)];
    }
  }
  extendTo(elem) {
    if(this.contains(elem)) {
      return [new Range(this.start, this.end, this.step)];
    } else if (elem > this.end) {
      let dist = toNearestStep(elem-this.end, this.step);
      return [new Range(this.start, this.end + dist, this.step)];
    } else if (elem < this.start) {
      let dist = toNearestStep(this.start - elem, this.step);
      return [new Range(this.start - dist, this.end, this.step)];
    }
  }
  jump(elem) {
    if(this.start === this.end && this.step === 1) {
      if(elem > this.start) {
        return [new Range(this.start, elem, elem-this.start)];
      } else {
        return [new Range(elem, this.end, this.end-elem)];
      }
    } else {
      return [new Range(this.start, this.end, this.step), new Range(elem, elem, 1)];
    }
  }
  isGreaterThan(range) {
    if (this.end > range.end) {
      return true;
    } else {
      return false;
    }
  }
  map(cb) {
    return [new Range(cb(this.start), cb(this.end), cb(this.step))];
  }
}

class BigNumArray {
  constructor () {
    this.storage = [];
  }
  push(elem) {
    if (this.storage.length > 0) {
      let isAdj = false;
      let modifiedRange;
      let modifiedRangeIndex;
      this.storage.forEach((range, index) => {
        if (range.isAdjacent(elem)) {
          if (!isAdj) {
            let joinedRange = range.extendTo(elem);
            this.storage[index] = joinedRange[0];
            let modifiedRange = this.storage[index];
            let modifiedRangeIndex = index;
            isAdj = true;
          }
        }
      });
      if (isAdj === false) {
        this._addSingle(elem);
      } else {
        this._joinRanges();
      }
    } else {
      this._addSingle(elem);
    }
  }
  pushRange(start, end, step) {
    let addedRange = new Range(start, end, step);
    this.storage.push(addedRange);
    this._joinOnRange(this.storage.length-1, true);
  }
  contains(elem) {
    return this.storage.reduce((prev, curr) => {
      if(prev) {
        return true;
      } else {
        return curr.contains(elem);
      }
    }, false)
  }
  _joinRanges() {
    for(var i = 0; i < this.storage.length; i ++) {
      this._joinOnRange(i, false);
    }
  }
  _joinOnRange(index, shouldCheckAll) {
    let firstRange = this.storage[index];
    for(var i = shouldCheckAll ? 0 : index; i < this.storage.length; i ++) {
      if(this.storage[i].isAdjacentRange(firstRange)) {
        let joinedRange = this.storage[i].join(firstRange);
        this.storage.splice(i, 1);
        this.storage[index] = joinedRange[0];
      };
    }
  }
  _addSingle(elem) {
    this.storage.push(new Range(elem, elem, 1));
  }
  remove(elem) {
    let done = false;
    if (!this.contains(elem)) {
      return false;
    } else {
      this.storage.forEach((range, index) => {
        if(range.contains(elem)) {
          let splitRanges = range.remove(elem);
          done = true;
          if(splitRanges.length === 1) {
            this.storage[index] = splitRanges[0];
          } else {
            this.storage.splice(index, 1, ...splitRanges);
          }
        }
      });
      return done;
    }
  }
  map(cb) {
    this.storage = this.storage.map(range => {
      return range.map(cb)[0];
    });
  }
  toArray() {
    let retval = [];
    this.storage.forEach(range => {
      retval = retval.concat(range.toArray());
    });
    return retval;
  }
  sortRaw() {
    this.storage.sort((a, b) => {
      return a.isGreaterThan(b);
    });
  }
}

module.exports = {
  Range,
  BigNumArray
};